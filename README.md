# Sparse-V: RISC-V Integrated Structured Sparsity Accelerator

## ðŸš€ Overview
Sparse-V is a highly efficient hardware accelerator designed for TinyML applications on edge devices. It leverages **2:4 Structured Sparsity** to skip redundant computations (zero-valued weights), delivering high-performance matrix multiplication with minimal silicon area usage. The IP is wrapped with an **AXI4-Lite** interface, making it plug-and-play compatible with RISC-V processors (e.g., Ibex, CV32E40P).

## ðŸ“Š Key Performance Metrics
| Metric | Baseline (RISC-V CPU) | Sparse-V (This Work) | Improvement |
| :--- | :--- | :--- | :--- |
| **Latency (4x4 Matrix)** | ~128 Cycles | **9 Cycles** | **14.2x Speedup** ðŸš€ |
| **Throughput** | Sequential | Parallel (4 PE) | 4x Throughput |
| **Area Cost** | N/A | **37 LUTs / 68 FFs** | <1% FPGA Area |
| **Efficiency** | Standard | 50% Weight Compression | 2x Memory Bandwidth |

## ðŸ› ï¸ Tech Stack
* **Hardware Design:** SystemVerilog (IEEE 1800-2017)
* **Interface:** AXI4-Lite Slave Protocol
* **Verification:** Vivado 2025.1 Simulator & Python (NumPy/TensorFlow)
* **Synthesis:** Xilinx Vivado (Target: Artix-7 / Zynq-7000)

## ðŸ“‚ Repository Structure
/src 
	â”œâ”€â”€ sparse_core.sv # The math engine (4 Parallel PEs) 
	â”œâ”€â”€ sparse_pe.sv # Processing Element logic 
	â”œâ”€â”€ sparse_pkg.sv # SystemVerilog data types & structs 
	â”œâ”€â”€ axi_sparse_wrapper.sv # AXI4-Lite Bus Interface 
/sim 
	â”œâ”€â”€ tb_axi_sparse_wrapper.sv # Master Testbench (CPU Emulation) 
	â”œâ”€â”€ weights_nz.mem # Compressed Weights (Generated by Python) 
	â”œâ”€â”€ indices.mem # Sparsity Indices (Generated by Python) /scripts 
	â”œâ”€â”€ sparsity_generator.py # Python script for pruning & packing

## ðŸ—ï¸ Architecture
The design consists of a Systolic Array-like structure where 4 Processing Elements (PEs) operate in parallel. Each PE handles a specific row of the weight matrix, utilizing **indirect indexing** to fetch activations based on sparsity metadata.

## ðŸ“ˆ Verification Results
Functionality was verified by comparing hardware simulation outputs against a Golden Reference Model in Python.
* **Input:** Random INT8 vectors
* **Weights:** 2:4 Pruned & Quantized Matrix
* **Result:** Exact match with software calculated dot products.
